#!/bin/sh
#
# `pomo`: Simple pomodoro timer
#
# Dependencies:
#	- POSIX `rm`
#	- POSIX `stty`
#	- POSIX `sleep`
#	- `screen` or `tmux`
#	- `xterm`|`(u)rxvt`|`x-terminal-emulator` (work in progress)
# Environment:
#	- TMPDIR

: "${TMPDIR:=${TMP:=${TEMP:=/tmp}}}"

usage() {
	echo 'usage: pomo [ start <min>[m[<sec>s]] | pause | stop | resume ]'
	exit
} >&2

error() {
	printf '%s: %s\n' "${0##*/}" "$*"
	exit 1
} >&2

is_running() {
	kill -0 "$1"
} 2>/dev/null

stop() {
	kill "$pid" 2>/dev/null
	[ -e "$log_file" ] && rm "$log_file"
}

pause() {
	kill "$pid" 2>/dev/null

	# TODO: Is there a better way? This seems clumsy.
	#
	# `kill` doesn't kill immediately and without this `check` prints
	# the wrong message.
	while is_running "$pid"; do
		:
	done

	check
}

check() {
	[ -e "$log_file" ] || error 'no timer info available'

	if ! is_running "$pid"; then
		printf 'paused: %02dm%02ds\n' $((time / 60)) $((time % 60))
	else
		printf 'remaining: %02dm%02ds\n' $((time / 60)) $((time % 60))
	fi
}

alert() {
	read -r lines cols <<-EOF
		$(stty size)
	EOF

	x=$((cols / 2 - 15))
	y=$((lines / 2 - 6))

	r=$(printf '\033[7m') # Reverse
	c=$(printf '\033[0m') # Clear

	print() {
		for line do
			# Position cursor and print line.
			printf '\033[%s;%sH%s' "$y" "$x" "$line"
			y=$((y + 1))
		done
	}

	# ###  ###  #####  ###  #   #
	# #  # #  # #     #   # #  #
	# ###  ###  ####  ##### ###
	# #  # #  # #     #   # #  #
	# ###  #  # ##### #   # #   #
	#
	#   ##### # #   # ##### #
	#     #   # ## ## #     #
	#     #   # # # # ####  #
	#     #   # #   # #
	#     #   # #   # ##### #
	#
	print \
	"$r    $c  $r    $c  $r     $c  $r   $c  $r $c   $r $c" \
	"$r $c   $r $c $r $c   $r $c $r $c     $r $c   $r $c $r $c  $r $c" \
	"$r    $c  $r    $c  $r    $c  $r     $c $r   $c" \
	"$r $c   $r $c $r $c   $r $c $r $c     $r $c   $r $c $r $c  $r $c" \
	"$r    $c  $r $c   $r $c $r     $c $r $c   $r $c $r $c   $r $c" \
	"" \
	"    $r     $c $r $c $r $c   $r $c $r     $c $r $c" \
	"      $r $c   $r $c $r  $c $r  $c $r $c     $r $c" \
	"      $r $c   $r $c $r $c $r $c $r $c $r    $c  $r $c" \
	"      $r $c   $r $c $r $c   $r $c $r $c" \
	"      $r $c   $r $c $r $c   $r $c $r     $c $r $c" \
	""

	while print '🍅 Start new timer? [Y/n/<time>] '; read -r reply; do
		case "$reply" in
			[Yy]|[Yy]es|'') reply='25m' ;;
			[Nn]|[Nn]o) return ;;
			*[!0-9ms]*) continue ;;
		esac
		break
	done

	start "$reply"
}

timer() {
	ps -p "$$" -o pid,ppid,pgid,tty,cmd >/tmp/log # debug
	exec 2>/tmp/log # debug
	#set -x # debug

	time="$1" session="$2"

	while [ "$time" -gt 0 ]; do
		printf '%s %s\n' "$$" "$time" >"$log_file"
		time=$((time - 1))
		sleep 1
	done

	[ -e "$log_file" ] && rm "$log_file"

	# TODO: Probably a good few holes here. Is there a
	# terminal-independent way to do this?
	if [ -n "$STY" ]; then
		screen -S "$session" -X screen pomo alert
	elif [ -n "$TMUX" ]; then
		tmux neww -t "$session" pomo alert
	elif command -v xterm >/dev/null 2>&1; then
		xterm -e pomo alert
	elif command -v rxvt >/dev/null 2>&1; then
		rxvt -e pomo alert
	else
		x-terminal-emulator -e pomo alert
	fi 2>/dev/null
}

start() {
	is_running "$pid" && error 'already running'

	# If `time` has already been read from the log file, it will be a
	# number in seconds but without an 's' suffix. This adds the 's'
	# back if it's missing. Otherwise we get an error below.
	[ -n "${time##*s}" ] && time="${time}s"

	: "${time:=${1:-25m}}"

	case $time in
		*m*s) min="${time%%m*}" sec="${time##*m}" sec="${sec%s}" ;;
		*m) min="${time%%m*}" ;;
		*s) sec="${time%s}" ;;
	esac

	case ${min}${sec} in
		*[!0-9]*|'') error "bad time format: $time"
	esac

	time=$((min * 60 + sec))

	if [ -n "$STY" ]; then
		session="$STY"
		screen -dmS pomodoro pomo timer "$time" "$session"
	elif [ -n "$TMUX" ]; then
		session=$(tmux display -pF '#{session_id}')
		tmux new -ds pomodoro pomo timer "$time" "$session"
	else
		# TODO: This doesn't work.
		#
		# See:
		# https://stackoverflow.com/a/20338327
		# https://stackoverflow.com/a/46621604
		# https://stackoverflow.com/a/3095624
		# https://serverfault.com/a/312265
		# https://serverfault.com/a/311602
		#
		# NOTE: Apparently the `double fork` is "wrongheaded"
		#
		# See:
		# https://unix.stackexchange.com/a/194208
		# https://unix.stackexchange.com/a/177361
		# https://web.archive.org/web/20160408151852/http://homepage.ntlworld.com/jonathan.deboynepollard/FGA/unix-daemon-design-mistakes-to-avoid.html
		(
			exec 2>/tmp/log # debug
			set -x # debug
			pomo timer "$time" &
			read -r _ # debug
			# NOTE: at this point the timer (grandchild) has PPID
			# of the child process (this subshell)
		)
		# NOTE: at this point the child has exited and the
		# grandchild is adopted by systemd (PID != 1, see above
		# links) and has the corresponding PPID of systemd. But
		# its PGID (group leader) is still that of the calling
		# terminal (the xterm window where the alert prompt was
		# displayed)
	fi

	# NOTE: At this point there may be two timers running at the same
	# time. Investigate further!

	echo "calling xterm pid: $$" >/tmp/log # debug
	read -r _ # debug
	exit 0 # debug

	# NOTE: After this function returns, the xterm exits, and the
	# grandchild, whose process group leader has died, also dies. So
	# its the PGID we need to change.
}

main() {
	[ $# -gt 3 ] && usage

	log_file="$TMPDIR/pomo.log"

	[ -e "$log_file" ] && read -r pid time <"$log_file"

	case $1 in
		start) start "$2" ;;
		pause) pause ;;
		stop) stop ;;
		timer) timer "$2" "$3" ;;
		alert) alert ;;
		'') check ;;
		-h) usage ;;
		*) ! usage ;;
	esac
}

main "$@"

