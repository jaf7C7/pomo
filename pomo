#!/bin/sh
#
# `pomo`: Simple pomodoro timer
#
# Dependencies:
#	- POSIX utilities `rm` `ps` `stty` `sleep`
#	- One of: `screen` `tmux` `xterm` `(u)rxvt`
# Environment:
#	- TMPDIR

# Open a new file descriptor for error messages, so they don't get lost
exec 3>&2

: "${TMPDIR:=${TMP:=${TEMP:=/tmp}}}"

usage() {
	printf '%s\n' \
	'usage: pomo [ start [<min>[m[<sec>s]]] | pause | stop ]'
	exit
} >&3

error() {
	printf '%s: %s\n' "${0##*/}" "$*"
	exit 1
} >&3

timer_alive() {
	# `kill -0` has no effect but checks for a valid pid, i.e. an
	# existing process.
	kill -0 "$pid"
}

timer_running() {
	[ -z "$pid" ] && return 1

	# POSIX doesn't specify `ps -o state` unfortunately, hence this
	# workaround to get the process state.
	while read -r F S _; do
		# Skip the line with the headers. 'F S UID PID ...'
		[ "$F" = 'F' ] && continue

		# R -> Running/runnable
		# S -> Interruptible sleep (probably sleep(1)ing)
		case $S in
			R|S) return 0
		esac

	done <<-EOF
		$(ps -lp "$pid")
	EOF

	return 1
}

# Parses the '<min>m<sec>s' time format and sets the `time` variable.
get_time() {
	time="${1:-25m}"

	case $time in
		*m*s) min="${time%%m*}" sec="${time##*m}" sec="${sec%s}" ;;
		*m) min="${time%%m*}" ;;
		*s) sec="${time%s}" ;;
	esac

	case ${min}${sec} in
		*[!0-9]*|'') error "bad time format: $time"
	esac

	time=$((min * 60 + sec))
}

# Sets the `term` variable. Has to be called outside of the timer process
# because the timer has no controlling terminal.
get_term() {
	_pid=$$

	# Follow the process tree back up until we find an ancestor not
	# associated with a tty. This will be the terminal emulator itself.
	until [ "$tty" = '?' ]; do
		read -r ppid tty cmd <<-EOF
			$(ps -p "$_pid" -o ppid=,tty=,comm=)
		EOF

		_pid="$ppid"
	done

	term="$cmd"
}

alert_cmd() {
	# TODO: Make this portable/terminal independent. Probably just
	# `tmux` is the best solution.
	case $term in
		screen|SCREEN)
			screen -S "$session" -X screen pomo alert
		;;
	
		tmux*)
			tmux neww -t "$session" pomo alert
		;;

		# TODO: Test more terminals.
		xterm|*rxvt*)
			"$term" -e pomo alert
		;;

		*)
			stop
			error "terminal not supported: $term"
		;;
	esac
}

stop() {
	kill "$pid"

	# If the timer is stopped it won't notice the kill signal until
	# it's started again.
	kill -s CONT "$pid"

	rm "$log_file"
} 2>/dev/null

pause() {
	kill -s STOP "$pid"
	check
}

check() {
	timer_alive || error 'no timer info available'

	if timer_running; then
		printf '%s' 'remaining: '
	else
		printf '%s' 'paused: '
	fi

	printf '%02dm%02ds\n' $((time / 60)) $((time % 60))
}

alert() {
	trap 'stop; exit 1' INT

	kill -s STOP "$pid"

	read -r lines cols <<-EOF
		$(stty size)
	EOF

	x=$((cols / 2 - 15))
	y=$((lines / 2 - 6))

	r=$(printf '\033[7m') # Reverse
	c=$(printf '\033[0m') # Clear

	print() {
		for line do
			# Position cursor and print line.
			printf '\033[%s;%sH%s' "$y" "$x" "$line"
			y=$((y + 1))
		done
	}

	# ###  ###  #####  ###  #   #
	# #  # #  # #     #   # #  #
	# ###  ###  ####  ##### ###
	# #  # #  # #     #   # #  #
	# ###  #  # ##### #   # #   #
	#
	#   ##### # #   # ##### #
	#     #   # ## ## #     #
	#     #   # # # # ####  #
	#     #   # #   # #
	#     #   # #   # ##### #
	#
	print \
	"$r    $c  $r    $c  $r     $c  $r   $c  $r $c   $r $c" \
	"$r $c   $r $c $r $c   $r $c $r $c     $r $c   $r $c $r $c  $r $c" \
	"$r    $c  $r    $c  $r    $c  $r     $c $r   $c" \
	"$r $c   $r $c $r $c   $r $c $r $c     $r $c   $r $c $r $c  $r $c" \
	"$r    $c  $r $c   $r $c $r     $c $r $c   $r $c $r $c   $r $c" \
	"" \
	"    $r     $c $r $c $r $c   $r $c $r     $c $r $c" \
	"      $r $c   $r $c $r  $c $r  $c $r $c     $r $c" \
	"      $r $c   $r $c $r $c $r $c $r $c $r    $c  $r $c" \
	"      $r $c   $r $c $r $c   $r $c $r $c" \
	"      $r $c   $r $c $r $c   $r $c $r     $c $r $c" \
	""

	while print '🍅 Start new timer? [Y/n/<time>] '; read -r reply; do
		case "$reply" in
			[Yy]|'')
				unset reply
			;;

			[Nn])
				stop
				return
			;;

			*[!0-9ms]*)
				continue
			;;
		esac

		break
	done

	get_time "$reply"

	# Update the log file, from which the `timer` process
	# will read the new starting time.
	printf '%s %s\n' "$pid" "$time" >"$log_file"

	start
}

timer() {
	time="$1" term="$2" session="$3"

	while :; do
		while [ "$time" -gt 0 ]; do
			printf '%s %s\n' "$$" "$time" >"$log_file"
			time=$((time - 1))
			sleep 1
		done

		# Reset the timer to 0 once the countdown is finished.
		printf '%s %s\n' "$$" 0 >"$log_file"
		
		alert_cmd

		# The alert function stops the timer, and updates the time
		# in the log file. If/when the timer resumes it will read
		# the updated time from the log file and then just start
		# over again.
		read -r _ time <"$log_file"
	done
}

start() {
	timer_running && error 'already running'

	timer_alive && {
		kill -s CONT "$pid"
		return
	}

	[ -n "$time" ] || get_time "$@"
	[ -n "$term" ] || get_term

	[ -n "$STY" ] && session="$STY"
	[ -n "$TMUX" ] && session=$(tmux display -p '#{session_id}')

	# `(...)` creates a child process, `&` creates a grandchild process.
	#
	# The child shell exits and the grandchild is orphaned, and will not
	# be sent the 'HUP' signal if the grandparent exits.
	( pomo timer "$time" "$term" "$session" & )
}

main() {
	log_file="$TMPDIR/pomo.log"

	[ -e "$log_file" ] && read -r pid time <"$log_file"

	case $1 in
		start) start "$2" ;;
		pause) pause ;;
		stop) stop ;;
		timer) timer "$2" "$3" ;;
		alert) alert ;;
		'') check ;;
		-h) usage ;;
		*) ! usage ;;
	esac
}

main "$@"

