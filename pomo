#!/bin/sh
#
# `pomo`: Simple pomodoro timer
#
# Dependencies:
#	- POSIX `rm`
#	- POSIX `stty`
#	- POSIX `sleep`
#	- One of: `xterm`|`(u)rxvt`|`x-terminal-emulator`|`screen`|`tmux`
# Environment:
#	- TMPDIR

exec 3>&2

: "${TMPDIR:=${TMP:=${TEMP:=/tmp}}}"

usage() {
	echo 'usage: pomo [ start <min>[m[<sec>s]] | pause | stop | resume ]'
	exit
} >&3

error() {
	printf '%s: %s\n' "${0##*/}" "$*"
	exit 1
} >&3

alert() {
	read -r lines cols <<-EOF
		$(stty size)
	EOF

	x=$((cols / 2 - 15))
	y=$((lines / 2 - 6))

	r=$(printf '\033[7m') # Reverse
	c=$(printf '\033[0m') # Clear

	print() {
		for line do
			# Position cursor and print line.
			printf '\033[%s;%sH%s' "$y" "$x" "$line"
			y=$((y + 1))
		done
	}

	# ###  ###  #####  ###  #   #
	# #  # #  # #     #   # #  #
	# ###  ###  ####  ##### ###
	# #  # #  # #     #   # #  #
	# ###  #  # ##### #   # #   #
	print \
	"$r    $c  $r    $c  $r     $c  $r   $c  $r $c   $r $c" \
	"$r $c   $r $c $r $c   $r $c $r $c     $r $c   $r $c $r $c  $r $c" \
	"$r    $c  $r    $c  $r    $c  $r     $c $r   $c" \
	"$r $c   $r $c $r $c   $r $c $r $c     $r $c   $r $c $r $c  $r $c" \
	"$r    $c  $r $c   $r $c $r     $c $r $c   $r $c $r $c   $r $c"
	y=$((y + 1))

	#   ##### # #   # ##### #
	#     #   # ## ## #     #
	#     #   # # # # ####  #
	#     #   # #   # #
	#     #   # #   # ##### #
	print \
	"    $r     $c $r $c $r $c   $r $c $r     $c $r $c" \
	"      $r $c   $r $c $r  $c $r  $c $r $c     $r $c" \
	"      $r $c   $r $c $r $c $r $c $r $c $r    $c  $r $c" \
	"      $r $c   $r $c $r $c   $r $c $r $c" \
	"      $r $c   $r $c $r $c   $r $c $r     $c $r $c"
	y=$((y + 1))

	while print 'ðŸ… Start new timer? [Y/n/<time>] '; read -r reply; do
		case "$reply" in
			[Yy]|[Yy]es|'') reply='25m' ;;
			[Nn]|[Nn]o) return ;;
			*[!0-9ms]*) continue ;;
		esac
		break
	done

	exec 2>/tmp/bat.$$.log # debug
	echo "alert:" >&2 # debug
	set -x # debug

	pomo start "$reply"
}

is_running() {
	kill -0 "$1"
} 2>/dev/null

check() {
	[ -e "$log_file" ] || error 'no timer info available'

	if ! is_running "$pid"; then
		printf 'paused: %02dm%02ds\n' $((time / 60)) $((time % 60))
	else
		printf 'remaining: %02dm%02ds\n' $((time / 60)) $((time % 60))
	fi
}

pause() {
	kill "$pid" 2>/dev/null

	# `kill` doesn't kill immediately and without this `check` prints
	# the wrong message.
	while is_running "$pid"; do
		:
	done

	check
}

stop() {
	kill "$pid" 2>/dev/null
	[ -e "$log_file" ] && rm "$log_file"
}

timer() {
	exec 2>/tmp/bat.$$.log # debug
	echo "timer: $0 $@" >&2 # debug
	set -x # debug

	time="$1" session="$2"

	while [ "$time" -gt 0 ]; do
		printf '%s %s\n' $$ "$time" >"$log_file"
		time=$((time - 1))
		sleep 1
	done

	stop

	# TODO: Probably a few holes in this.
	if [ -n "$STY" ]; then
		screen -S "$session" -X screen pomo alert
	elif [ -n "$TMUX" ]; then
		tmux neww -t "$session" pomo alert
	elif command -v xterm >/dev/null 2>&1; then
		xterm -e pomo alert
	elif command -v rxvt >/dev/null 2>&1; then
		rxvt -e pomo alert
	else
		x-terminal-emulator -e pomo alert
	fi
}

start() {
	exec 2>/tmp/bat.$$.log # debug
	echo "start: $0 $@" >&2 # debug
	set -x # debug

	is_running "$pid" && error 'already running'

	# If `time` has already been read from the log file, it will be a
	# number in seconds but without an 's' suffix. This adds the 's'
	# back if it's missing. Otherwise we get an error below.
	[ -n "${time##*s}" ] && time="${time}s"

	: "${time:=${1:-25m}}"

	case $time in
		*m*s) min="${time%%m*}" sec="${time##*m}" sec="${sec%s}" ;;
		*m) min="${time%%m*}" ;;
		*s) sec="${time%s}" ;;
	esac

	case ${min}${sec} in
		*[!0-9]*|'') error "bad time format: $time"
	esac

	time=$((min * 60 + sec))

	# Save the multiplexer session so the right session is targeted
	# for the eventual alert.
	[ -n "$STY" ] && session="$STY"
	[ -n "$TMUX" ] && session=$(tmux display -pF '#{session_id}')

	# See https://stackoverflow.com/a/20338327
	#
	# `(...)` starts a child process.
	# `&` starts a grandchild process.
	#
	# The child process exits almost immediately and the
	# grandchild process is orphaned.
	#
	# TODO: This doesn't work when executed from the 'alert' function, but
	# it does work when you type 'pomo start'.
	#( pomo timer "$time" "$session" & )
	( screen -dmS pomodoro pomo timer "$time" "$session" & )
}

main() {
	[ $# -gt 3 ] && usage

	log_file="$TMPDIR/pomo.log"

	[ -e "$log_file" ] && read -r pid time <"$log_file"

	case $1 in
		start) start "$2" ;;
		pause) pause ;;
		stop) stop ;;
		timer) timer "$2" "$3" ;;
		alert) shift; alert "$@";;
		'') check ;;
		-h) usage ;;
		*) ! usage ;;
	esac
}

main "$@"

